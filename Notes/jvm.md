# 深入理解JVM
## 1. 自动内存管理机制
### 1.1 内存区域
![runtimedata](./JVMRuntimeData.png)
1. 程序计数器
    > 程序计数器是一块较小的内存空间，他的作用可以看作是当前线程所执行字节码的行号指示器。
    > 字节码解释器工作时就是通过它的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖它来完成，
    > 此内存区域是唯一一个在JAVA虚拟机规范中没有规定任何OutOfMemoryError情况的区域。
2. 虚拟机栈
    > 它的生命周期与线程相同。
    > 虚拟机栈描述的是JAVA方法执行的内存模型，每个方法执行的时候都会同时创建一个栈帧用于存储局部变量表、操作栈、动态链接、方法出口等信息。每个方法执行完成的过程，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。
    > 只有64位的long 和double 类型的数据会占用两个局部变量空间。
    > 局部变量表所需的内存空间在编译期间完成分配，在进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，并且在方法运行期间不会改变局部变量表的大小。
    > 在JAVA虚拟机规范中对这个区域定义了两种异常：如果线程请求的栈深度大于虚拟机所允许的深度将抛出StackOverFlowError异常；如果虚拟机栈可以动态扩展，当扩展到无法申请到足够的内存是将抛出OutOfMemoryError异常。
3. 本地方法栈
    > 与虚拟机栈所发挥的作用类似，区别是虚拟机栈为虚拟机执行java方法（字节码）服务，而本地方法栈则是为虚拟机使用到的Native(非JAVA代码实现的JAVA方法)方法服务。
4. 堆
    > 是JAVA虚拟机所管理的内存中最大的一块 。
    > 是所有线程所共享的一块内存区域，在虚拟机启动时创建，唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所以所有对象都在堆上分配内存也渐渐的不是那么绝对了。
    > 堆是垃圾收集器的主要回收区域，因此很多时候也称为“GC堆”（垃圾堆？）。
    > 堆还可以细分为新生代和老年代；再细致一点的有Eden空间、From Survivor 空间、To Survivor空间等。
    > 根据JAVA虚拟机规范的规定，堆可以处于物理上不连续的内存空间中，只要逻辑上连续就可以。
    > 在实现时，既可以实现指定堆的大小，也可以指定为可扩展的，当前主流的JVM都是按照可扩展来实现的（-Xms和-Xmx控制）。
    > 如果堆中没有内存用来完成实例分配，将抛出OutOfMemoryError异常。
5. 方法区
    > 也是所有线程所共享的一块内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
    > 虽然JVM规范将方法区描述为堆的一个逻辑部分，但是它却有一个别名“非堆”。
    > 除了个对一样可以不需要连续的内存和可以选择固定大小和可扩展之外，还可以选择不实现垃圾收集。
6.  运行时常量池
    > 运行时常量池是方法区的一部分。class文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。
    > 一般来说除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。
    > 运行时常量池相对于Class文件常量池的另外的一个重要特性是俱杯动态性，java语言并不要求常量一定只能在编译器产生，也就是非预置入的Class文件中的常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入常量池中。String类的intern就是一个代表。
7.  直接内存
    > 这并不是虚拟机运行时的数据区的一部分，也不是Java虚拟机规范中定义的区域，但是这部分内存也被频繁的使用，而且也可能导致OutOfMmemoryError异常。
    > 比如NIO方法他使用Native库函数直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。
8.  对象访问
    > 比如 Object obj = new Object();  Object obj 将会反映到JAVA栈的本地变量表中作为reference类型数据,而 new Object() 这部分语义会反映到JAVA堆中。另外在JAVA堆中还必须包含能查找到此对象的类型数据的地址信息,这些类型数据存储在方法区。
    > 由于reference在JVM规范里只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式定位，以及访问JAVA堆中的对象的具体位置。所以不同的虚拟机访问方式会有所不同。
    > 主流的访问方式有两种：使用句柄和直接指针。
    >   > 使用句柄方式，JAVA堆中将会分配一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象示例数据和类型数据各自的具体地址信息。
	>	> 使用直接指针访问方式，java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象地址。
	>	> 这两种对象的访问方式各有优势，使用句柄的最大好处就reference中存储的是稳定的句柄地址，在对象被移动时（GC）只会改变句柄中的实例数据指针，而reference本身不需要修改。而使用直接指针访问的最大好处就是速度快，他节省了一次指针定位的时间开，由于对象的访问在java中非常频繁，因此这类开销积少成多是非常可观的。
** *
### 1.2 垃圾收集
1. 概述
	> 垃圾收集的历史远远比Java久远，1960年诞生于MIT的Lisp是第一门真正使用内存动态分配和垃圾收集技术的语言。
2. 引用计数法
	> 很多教科书判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，每当有一个地方引用他时，计数器就加1；当引用失效时计数器就减一；任何时刻计数器都为零的对象就是不可能在被使用的。
	> 引用计数法的实现简单，判断效率也很高，在大部分情况下他都是一个不错的算法，但是很难解决对象之间的相互循环引用。
3. 根搜索算法
	> 通过一系列的名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所有走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连（从GC Roots到这个对象不可达）时，则证明此对象不可用的。
	>	> 在Java里可作为GC Roots的对象包括下面几种:
	>	> * 虚拟机栈（栈帧中的本地变量表）中的引用的对象。
	>	> * 方法区中的类静态属性引用的对象。
	>	> * 方法区中的常量引用的对象。
	>	> * 本地方法栈中的JNI （即一般说的Native方法）的引用的对象。
4. 再谈引用
	> 在JDK1.2之前，JAVA中的引用的定义很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的开始地址，就成为这块内存代表着一个引用。
	> 在JDK1.2 之后，Java对引用概念进行了扩充，将引用分为强引用（Strong Reference），软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）四种。这四种引用强度依次逐渐减弱。
	>	> 强引用就是指在程序代码之中普遍存在的。类似“Object obj = new Object();” 这类的引用，只要强引用还存在，垃圾收集器永远不会回收。
	>	> 软引用用来描述一下还有用，但并非必须的对象。在系统将要发生内存溢出异常值钱，将会把这些对象列进回收范围之中并进行第二次回收。
	>	> 弱引用也是用来描述非必须对象的，但是他的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。
	>	> 虚引用也称为幽灵引用或者幻影引用，他是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成有影响，也无法铜鼓虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。
5. 对象生存周期
	> 在跟搜索算法中不可达的对象，也并非是非死不可，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行跟搜索后发现没有与GC Roots相连接的引用链，那他将会被第一次标记并进行一次筛选（是否有必要执行finalize（）方法,如果没有finalize（）方法或者已经执行过了则没必要执行）。如果有必要执行这个对象会被放在一个F-Queue的队列之中，并在稍后由一条虚拟机自动建立的、低优先级的Finalizer线程去执行。这里所谓的执行是指虚拟机会触发这个方法，但并不承诺会等待他运行结束（防止如果执行缓慢或者发生了死循环阻塞队列中其他对象，甚至到时整个内存回收系统崩溃）。稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对想要在finalize（）中成功拯救自己只要重新与引用链上的任何一个对象建立关联即可，在第二次标记是他将被移除出“即将回收“的集合。
	> 任何一个对象的finalize（）方法都只会被系统自动调用一次。
	> finalize()能做的所有工作，使用try-finally或其他方式都可以做的更好、更及时，完全可以忘掉这个方法的存在。
6. 回收方法区
	> Java虚拟机规范中描述可以不要求虚拟机在方法区（永久代）实现垃圾收集，而且在方法区进行垃圾收的新家比一般比较低。
	> 永久代的垃圾收集主要回收两部分内容：废弃的常量和无用的类。
	> 判断废弃的常量与回收Java堆中的对象非常类似，如果没有任何对象引用这个常量也没有其他地方引用了这个字面量，如果在这个时候发生内存回收，而且必要的话，这个常量会被系统”请“出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。
	> 判断一个无用的类需要同时满足下面的三个条件：
	>	> 该类的所有实例都已经被回收，也就是Java堆中不存在该类的任何实例。
	>	> 加载该类的ClassLoader已经被回收。
	>	> 该类对应的Java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
	> 虚拟机可以对满足上述三个条件的我要用类进行回收，这里说的仅仅是”可以，而不是和对象一样，不使用了就必然会回收。
	> 在大量使用反射、动态代理、GCLib等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。
7. 垃圾收集算法
	1. 标记 - 清除算法
		> 算法分为”标记”和“清除”两个阶段：首先标出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。它的主要缺点有两个：一个是效率问题，标记和清除过程的效率都不高；另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当前程序在以后的运行过程中需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。
	2. 复制算法
		> 他将可用内存容量划分为大小相等的两块，每次只使用其中的一块。当着一块内存用完了，就将还存活的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。（实现简单，运行高效。）缺点：只有一半的可用内存。
		> 现在的商业虚拟机都采用这种收集算法来回收新生代，IBM的专门研究表明，诞生代中的对象98%是朝生夕死的，所以不小1：1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外的一块Survivor空间上，最后清理掉Eden和刚才使用过的Survivor的空间。当Survivor空间不够用是，需要依赖其他内存（这里指老年代）进行分配担保。
	3. 标记 - 整理算法
		> 复制收集算法在对象存活率比较高时就要执行较多的复制操作，效率将会变低。更关键是如果不想浪费50%的空间就需要额外的空间进行分配担保，所以老年代一般不能直接选用这种算法。
		> 标记过程仍然和之前的算法一样，但后续步骤部署直接对可回收对象进行清理，而是让所有对象都向一端移动，然后直接清理掉端边界以外的内存。
	4. 分代收集算法
		> 当前商业虚拟机的垃圾收集都采用“分代收集”算法，只是根据对象的存活周期的不同将没存划分为几块。
		> 一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最社党的收集算法。
		> 在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代
8. 垃圾收集器
	1. Serial收集器
		> Serial是最基本的、历史最悠久的收集器，曾经在JDK1.3.1之前是虚拟机新生代收集的唯一选择。
		> 它是一个单线程收集器，更重要的是在他进行垃圾收集时，必须暂停其他所有的工作线程，SUN 称之为”Stop The Word“，直到他收集结束。
		> 优点是简单高效一般用于client模式因为client一般新生代不会很大，所以停顿时间可以控制在几十毫秒最多一百多毫秒以内。
	2. ParNew 收集器
		> 其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有参数。
		> 除了多线程之外，其他与Serial收集器相对没有太多创新之处，但他确实许多运行在Server模式下的虚拟机中首选的新生代收集器，其中一个与性能无关但很重要的原因是除了Serial收集器外，目前只有它能与CMS收集器配合工作。
	3. Parallel Scavenge 收集器
		> 也是一个新生代收集器，他也是使用复制算法的收集器，有事并行的多线程收集器。
		> 他的目标和其他收集器不通，其他收集器一般都是尽可能缩短垃圾收集时用户现成的停顿时间，而它的目标则是达到一个可控制的吞吐量。
		>	> 停顿时间越短就越适合需要与用户交互的程序，良好的享用速递能提升用户的体验；而吞吐量则可以最高效率的利用CPU时间，尽快的完成程序的运算任务，主要适合在后他运算而不需要太多交互的任务。
		> 由-XX:MaGCPauseMillis来控制最大垃圾收集停顿时间（JVM只能极力保证），和由-XX:GCTimeRatio来设置吞吐量的大小（如果设置19 即1/（1+19）= 5%）。
	4. Serial Old 收集器
		> 是Serial收集器的老年版本，他同样是单线程收集器，使用”标记=整理“算法。
	5. Parallel Old收集器
		> 是Parallel Scavenge收集器的老年代版本，使用多线程和”编辑-整理“算法。
	6. CMS 收集器
		> 是一种以获取最短回收停顿时间为目标的收集器，重视服务的响应速度。基于”标记-清除“算法。
		> 工作过程为4个步骤，初始标记、并发标记、重新标记、并发清除。
		> 其中初始标记、重新标记这两个步骤仍然需要停止其他线程，初始标记就是编辑一下GC Roots 能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记时间短。

